# 语法树	

​        首先先定义一个语法树。每个节点定义三个属性，类型、数值、子节点。

```
class Node:
    def __init__(self, Type, text=None):
        self.type = Type
        self.text = text
        self.child = list()
```

​      语法分析的另一个亮点是可以将语法树输出。这里主要用到两个for循环。第一个循环递归调用子节点，将每个节点都依此添加到列表中（用到了python中比较方便的.append函数）。第二个循环将子节点输出。每个子节点用如下字符串的形式将节点的类型和值输出。

```
out = "<{type}, {text}>".format(type=self.type, text=self.text)
```



# LR分析

​        经过几番严谨的思考，我们放弃了自顶向下的LL(1)和递归下降子程序，而采用了更适合所选文法的LR。

​       LR需要用到之前的predict预测表和词法分析出的Token表，用cur来存放分析栈的栈顶元素，逐一进行匹配。LR分析主要有以下四种状态。

```
分析预测表的四个状态
1. cur = #  解析完成
2. cur = w  输入的字符表与符号栈中节点匹配
3. cur 为非终结符，继续生成子节点
4. error
```

##### 1.解析完成

​		若栈顶元素是'#'，而且栈已经空了，说明所有字符均已匹配成功，解析完成。



##### 2.匹配终结符

​		如果当前栈顶元素与Token序列当前单词的类型一样，则说明栈顶元素是终结符，此时需要规约。已经匹配的字符为

```
word_table[index]['word']  
```

接着 index+1，以便匹配下一个单词。



##### 3.移进操作

如果都不是以上状况，那么需要判断是否需要移进。

先取出Token序列当前单词的类型，查找预测表，看它是否在预测表中。

```
if w in predict_table[cur.type]: 
```

若在，则移进。next_pr中存放已匹配的产生式。

接下来将产生式的每一个单词都生成一个语法树节点,Node(np).

然后逆序将产生式压入分析栈中（stack）。

```
node_list.reverse() 
```

##### 4.错误

若均不设以上情况，则报错。



# 心得

​		经过这次课设，有一点很明显的感悟，那就是听懂了和会做了差着十万八千里。在春季学期已经学习过了编译原理，当时只觉得符号表有点难，词法分析LL(1)的select集花了点时间理解，但总的来说还是比较简单，最后期末也还可以。但课设做起来却遇到了很多问题，上学期觉得很简单的问题做起来都很复杂。比如如何将语法树打印出来，就整整想了一天，最后巧妙的用了两个循环就解决了。第一个循环递归调用子节点，将每个节点都依此添加到列表中。第二个循环将子节点输出。每个子节点用out = "<{type}, {text}>"的形式输出。然后是LR分析的最核心的两个判断，判断此时到底是需要规约还是移进呢。再一个，因为编写编译器十分复杂，所以团队合作的重要性就显得越来越重。不只是自己写的部分，还要理解同学的代码，了解函数接口、功能等等。自己的代码也要多写注释，方便同学阅读。不然会降低程序可读性，拖延进度。对不是自己的部分也要充分了解。因为我符号表部分学的不是很好，所以分工时就刻意避开了这个办法。但符号表非常重要，需要充分理解才能更好进行下一阶段的工作，所以近期我也在学习符号表的部分。最后python的功能是真的强大，内置的很多函数减少了不少的开发时间。
